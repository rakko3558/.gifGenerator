<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>åœ–ç‰‡ç·¨è¼¯ + ç‰¹æ•ˆ â†’ GIF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 2em; }
    canvas { border: 1px solid #ccc; display: block; margin: 1em auto; cursor: grab; }
    #output img { max-width: 100px; margin: 4px; }
    .controls, .color-controls, .sliders { margin: 1em 0; }
    #downloadBtn { display: none; margin-top: 1em; }
    input[type=number], input[type=range] { width: 120px; }
    label { display: inline-block; margin: 0.5em; }
  </style>
</head>
<body>
  <h1>åœ–ç‰‡ç·¨è¼¯ + ç‰¹æ•ˆ â†’ GIF</h1>

  <input type="file" id="bgUpload" accept="image/png, image/jpeg"><br/>

  <div class="color-controls">
    <label for="bgColorPicker">èƒŒæ™¯è‰²ï¼š</label>
    <input type="color" id="bgColorPicker" value="#ffffff">
  </div>

  <div class="sliders">
    <label for="bgScaleRange">åº•åœ–ç¸®æ”¾æ¯”ä¾‹ï¼š</label>
    <input type="range" id="bgScaleRange" min="0.1" max="5" step="0.05" value="1">
  </div>

  <div class="sliders">
    <label for="effectScaleRange">ç‰¹æ•ˆç¸®æ”¾ï¼š</label>
    <input type="range" id="effectScaleRange" min="0.1" max="5" step="0.05" value="1">
  </div>

  <div class="sliders">
    <label for="effectOffsetYRange">ç‰¹æ•ˆ Y ä½ç§»ï¼š</label>
    <input type="range" id="effectOffsetYRange" min="-200" max="200" step="1" value="0">
  </div>

  <div class="sliders">
    <label for="effectOffsetXRange">ç‰¹æ•ˆ X ä½ç§»ï¼š</label>
    <input type="range" id="effectOffsetXRange" min="-200" max="200" step="1" value="0">
  </div>

  <div class="sliders">
    <label for="frameDelayRange">æ¯å¼µå»¶é²(ms)ï¼š</label>
    <input type="range" id="frameDelayRange" min="20" max="500" step="10" value="80">
  </div>

  <div class="controls checkbox-group" id="effectCheckboxes"></div>

  <button id="generateBtn">ç”¢ç”Ÿ GIF</button>
  <canvas id="canvas" width="256" height="256"></canvas>
  <div id="output"></div>
  <a id="downloadBtn">â¬‡ï¸ ä¸‹è¼‰ GIF</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const bgUpload = document.getElementById('bgUpload');
    const bgScaleRange = document.getElementById('bgScaleRange');
    const effectScaleRange = document.getElementById('effectScaleRange');
    const effectOffsetYRange = document.getElementById('effectOffsetYRange');
    const effectOffsetXRange = document.getElementById('effectOffsetXRange'); // ğŸ†•
    const frameDelayRange = document.getElementById('frameDelayRange');
    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const output = document.getElementById('output');
    const checkboxContainer = document.getElementById('effectCheckboxes');

    const effects = {};
    const effectChecks = {};

    let userScale = 1;
    let userOffsetX = 0;
    let userOffsetY = 0;
    let isDragging = false;
    let lastX = 0, lastY = 0;
    let baseFileName = "effect";
    let userImage = null;

    // === æ»‘é¼ æ“ä½œï¼ˆæ¡Œæ©Ÿï¼‰ ===
canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastX = e.offsetX;
  lastY = e.offsetY;
  canvas.style.cursor = 'grabbing';
});
canvas.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.style.cursor = 'grab';
});
canvas.addEventListener('mouseleave', () => isDragging = false);
canvas.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  userOffsetX += e.offsetX - lastX;
  userOffsetY += e.offsetY - lastY;
  lastX = e.offsetX;
  lastY = e.offsetY;
  drawPreviewFrame(0);
});
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -0.05 : 0.05;
  userScale = Math.min(5, Math.max(0.1, userScale + delta));
  bgScaleRange.value = userScale;
  drawPreviewFrame(0);
});

// === è§¸æ§æ”¯æ´ï¼ˆæ‰‹æ©Ÿï¼‰ ===
let pinchStartDistance = 0;
let pinchStartScale = 1;

canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    lastX = touch.clientX - rect.left;
    lastY = touch.clientY - rect.top;
    isDragging = true;
    canvas.style.cursor = 'grabbing';
  } else if (e.touches.length === 2) {
    pinchStartDistance = getTouchDistance(e.touches);
    pinchStartScale = userScale;
  }
});

canvas.addEventListener('touchmove', (e) => {
  if (e.touches.length === 1 && isDragging) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    userOffsetX += x - lastX;
    userOffsetY += y - lastY;
    lastX = x;
    lastY = y;
    drawPreviewFrame(0);
  } else if (e.touches.length === 2) {
    e.preventDefault();
    const newDistance = getTouchDistance(e.touches);
    const scaleDelta = newDistance / pinchStartDistance;
    userScale = Math.min(5, Math.max(0.1, pinchStartScale * scaleDelta));
    bgScaleRange.value = userScale.toFixed(2);
    drawPreviewFrame(0);
  }
}, { passive: false });

canvas.addEventListener('touchend', () => {
  isDragging = false;
  canvas.style.cursor = 'grab';
});

// å·¥å…·ï¼šå…©æŒ‡è·é›¢è¨ˆç®—
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

    [bgColorPicker, bgScaleRange, effectScaleRange, effectOffsetYRange, effectOffsetXRange].forEach(input => {
      input.addEventListener('input', () => drawPreviewFrame(0));
    });

    bgUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      baseFileName = file.name.replace(/\.[^/.]+$/, "");
      const reader = new FileReader();
      reader.onload = (evt) => {
        const img = new Image();
        img.onload = () => {
          userImage = img;
          userScale = 1;
          userOffsetX = 0;
          userOffsetY = 0;
          bgScaleRange.value = "1";
          drawPreviewFrame(0);
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    async function loadEffectFrames(name) {
      const frames = [];
      for (let i = 1; i <= 999; i++) {
        const num = i.toString().padStart(2, '0');
        const src = `gifs/${name}/frame${num}.png`;
        const img = new Image();
        img.src = src;
        await new Promise((res) => {
          img.onload = () => { frames.push(img); res(); };
          img.onerror = () => res();
        });
        if (img.width === 0) break;
      }
      return frames;
    }

    async function setupEffects() {
      const names = ['explode', 'loading', 'rain', 'fire', 'money', 'poop', 'heart1', 'heart2','sellass'];
      for (const name of names) {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = `effect_${name}`;
        label.appendChild(cb);
        label.append(` ${name}`);
        checkboxContainer.appendChild(label);
        effectChecks[name] = cb;
        cb.addEventListener('change', () => drawPreviewFrame(0));
        effects[name] = [];
      }
    }

    function drawPreviewFrame(frameIndex) {
      ctx.fillStyle = bgColorPicker.value;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (userImage) {
        ctx.save();
        ctx.translate(canvas.width / 2 + userOffsetX, canvas.height / 2 + userOffsetY);
        const bw = userImage.width * userScale;
        const bh = userImage.height * userScale;
        ctx.drawImage(userImage, -bw / 2, -bh / 2, bw, bh);
        ctx.restore();
      }

      const scale = parseFloat(effectScaleRange.value);
      const offsetY = parseInt(effectOffsetYRange.value);
      const offsetX = parseInt(effectOffsetXRange.value); // ğŸ†•

      for (const name in effectChecks) {
        if (effectChecks[name].checked && effects[name].length > 0) {
          const img = effects[name][frameIndex % effects[name].length];
          ctx.save();
          const ew = img.width * scale;
          const eh = img.height * scale;
          ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY); // ğŸ†•
          ctx.drawImage(img, -ew / 2, -eh / 2, ew, eh);
          ctx.restore();
        }
      }
    }

    generateBtn.addEventListener('click', async () => {
      if (!userImage) return alert("è«‹å…ˆä¸Šå‚³åº•åœ–ã€‚");

      const promises = Object.keys(effectChecks).map(async name => {
        if (effectChecks[name].checked && effects[name].length === 0) {
          effects[name] = await loadEffectFrames(name);
        }
      });
      await Promise.all(promises);

      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: canvas.width,
        height: canvas.height,
        repeat: 0,
        workerScript: 'gif.worker.js'
      });

      output.innerHTML = '<p>ç”¢ç”Ÿä¸­...</p>';
      downloadBtn.style.display = 'none';

      const maxFrames = Math.max(...Object.keys(effectChecks).map(name => (
        effectChecks[name].checked ? effects[name].length : 0
      )), 1);

      for (let i = 0; i < maxFrames; i++) {
        drawPreviewFrame(i);
        gif.addFrame(ctx, {
          copy: true,
          delay: parseInt(frameDelayRange.value)
        });
      }

      gif.on('finished', (blob) => {
        const url = URL.createObjectURL(blob);
        const img = document.createElement('img');
        img.src = url;
        output.innerHTML = '<p>é è¦½ï¼š</p>';
        output.appendChild(img);
        downloadBtn.href = url;
        downloadBtn.download = baseFileName + ".gif";
        downloadBtn.style.display = 'inline-block';
      });

      gif.render();
    });

    setupEffects();
  </script>
</body>
</html>
