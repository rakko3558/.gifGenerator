<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>圖片編輯 + 特效 → GIF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 2em; }
    canvas { border: 1px solid #ccc; display: block; margin: 1em auto; cursor: grab; }
    #output img { max-width: 100px; margin: 4px; }
    .controls, .color-controls, .sliders { margin: 1em 0; }
    #downloadBtn { display: none; margin-top: 1em; }
    input[type=number], input[type=range] { width: 120px; }
    label { display: inline-block; margin: 0.5em; }
  </style>
</head>
<body>
  <h1>圖片編輯 + 特效 → GIF</h1>

  <input type="file" id="bgUpload" accept="image/png, image/jpeg"><br/>

  <div class="color-controls">
    <label for="bgColorPicker">背景色：</label>
    <input type="color" id="bgColorPicker" value="#ffffff">
  </div>

  <div class="sliders">
    <label for="bgScaleRange">底圖縮放比例：</label>
    <input type="range" id="bgScaleRange" min="0.1" max="5" step="0.05" value="1">
  </div>

  <div class="sliders">
    <label for="effectScaleRange">特效縮放：</label>
    <input type="range" id="effectScaleRange" min="0.1" max="5" step="0.05" value="1">
  </div>

  <div class="sliders">
    <label for="effectOffsetYRange">特效 Y 位移：</label>
    <input type="range" id="effectOffsetYRange" min="-200" max="200" step="1" value="0">
  </div>

  <div class="sliders">
    <label for="frameDelayRange">每張延遲(ms)：</label>
    <input type="range" id="frameDelayRange" min="20" max="500" step="10" value="80">
  </div>

  <div class="controls checkbox-group" id="effectCheckboxes"></div>

  <button id="generateBtn">產生 GIF</button>
  <canvas id="canvas" width="256" height="256"></canvas>
  <div id="output"></div>
  <a id="downloadBtn">下載 GIF</a>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const bgUpload = document.getElementById('bgUpload');
    const bgScaleRange = document.getElementById('bgScaleRange');
    const effectScaleRange = document.getElementById('effectScaleRange');
    const effectOffsetYRange = document.getElementById('effectOffsetYRange');
    const frameDelayRange = document.getElementById('frameDelayRange');
    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const output = document.getElementById('output');
    const checkboxContainer = document.getElementById('effectCheckboxes');

    const effects = {};
    const effectChecks = {};

    let userScale = 1;
    let userOffsetX = 0;
    let userOffsetY = 0;
    let isDragging = false;
    let lastX = 0, lastY = 0;
    let baseFileName = "effect";
    let userImage = null;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastX = e.offsetX;
      lastY = e.offsetY;
      canvas.style.cursor = 'grabbing';
    });
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mouseleave', () => isDragging = false);
    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      userOffsetX += e.offsetX - lastX;
      userOffsetY += e.offsetY - lastY;
      lastX = e.offsetX;
      lastY = e.offsetY;
      drawPreviewFrame(0);
    });
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.05 : 0.05;
      userScale = Math.min(5, Math.max(0.1, userScale + delta));
      bgScaleRange.value = userScale;
      drawPreviewFrame(0);
    });

    [bgColorPicker, bgScaleRange, effectScaleRange, effectOffsetYRange].forEach(input => {
      input.addEventListener('input', () => drawPreviewFrame(0));
    });

    bgUpload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      baseFileName = file.name.replace(/\.[^/.]+$/, "");
      const reader = new FileReader();
      reader.onload = (evt) => {
        const img = new Image();
        img.onload = () => {
          userImage = img;
          userScale = 1;
          userOffsetX = 0;
          userOffsetY = 0;
          bgScaleRange.value = "1";
          drawPreviewFrame(0);
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    async function loadEffectFrames(name) {
      const frames = [];
      for (let i = 1; i <= 999; i++) {
        const num = i.toString().padStart(2, '0');
        const src = `gifs/${name}/frame${num}.png`;
        const img = new Image();
        img.src = src;
        await new Promise((res) => {
          img.onload = () => { frames.push(img); res(); };
          img.onerror = () => res();
        });
        if (img.width === 0) break;
      }
      return frames;
    }

    async function setupEffects() {
      const names = ['explode', 'loading', 'rain', 'fire','money','poop','heart1','heart2'];
      for (const name of names) {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = `effect_${name}`;
        label.appendChild(cb);
        label.append(` ${name}`);
        checkboxContainer.appendChild(label);
        effectChecks[name] = cb;
        cb.addEventListener('change', () => drawPreviewFrame(0));
        effects[name] = [];
      }
    }

    function drawPreviewFrame(frameIndex) {
      ctx.fillStyle = bgColorPicker.value;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (userImage) {
        ctx.save();
        ctx.translate(canvas.width / 2 + userOffsetX, canvas.height / 2 + userOffsetY);
        const bw = userImage.width * userScale;
        const bh = userImage.height * userScale;
        ctx.drawImage(userImage, -bw / 2, -bh / 2, bw, bh);
        ctx.restore();
      }

      const scale = parseFloat(effectScaleRange.value);
      const offsetY = parseInt(effectOffsetYRange.value);
      for (const name in effectChecks) {
        if (effectChecks[name].checked && effects[name].length > 0) {
          const img = effects[name][frameIndex % effects[name].length];
          ctx.save();
          const ew = img.width * scale;
          const eh = img.height * scale;
          ctx.translate(canvas.width / 2, canvas.height / 2 + offsetY);
          ctx.drawImage(img, -ew / 2, -eh / 2, ew, eh);
          ctx.restore();
        }
      }
    }

    generateBtn.addEventListener('click', async () => {
      if (!userImage) return alert("請先上傳底圖。");
      const promises = Object.keys(effectChecks).map(async name => {
        if (effectChecks[name].checked && effects[name].length === 0) {
          effects[name] = await loadEffectFrames(name);
        }
      });
      await Promise.all(promises);

      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: canvas.width,
        height: canvas.height,
        repeat: 0,
        workerScript: 'gif.worker.js'
      });

      output.innerHTML = '<p>產生中...</p>';
      downloadBtn.style.display = 'none';

      const maxFrames = Math.max(...Object.keys(effectChecks).map(name => (
        effectChecks[name].checked ? effects[name].length : 0
      )), 1);

      for (let i = 0; i < maxFrames; i++) {
        drawPreviewFrame(i);
        gif.addFrame(ctx, {
          copy: true,
          delay: parseInt(frameDelayRange.value)
        });
      }

      gif.on('finished', (blob) => {
        const url = URL.createObjectURL(blob);
        const img = document.createElement('img');
        img.src = url;
        output.innerHTML = '<p>預覽：</p>';
        output.appendChild(img);
        downloadBtn.href = url;
        downloadBtn.download = baseFileName + ".gif";
        downloadBtn.style.display = 'inline-block';
      });

      gif.render();
    });

    setupEffects();
  </script>
</body>
</html>
